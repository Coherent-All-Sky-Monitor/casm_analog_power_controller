#!/usr/bin/env python3
"""
CAPC - CASM Analog Power Controller CLI

A command-line interface for controlling CASM power switches.
Supports 4 control modes:
  1. Main Server + Switch Name: capc -n CH1A
  2. Main Server + Stack/Relay: capc -s 1 -r 7
  3. Pi Direct + Switch Name:   capc -n CH1A -d
  4. Pi Direct + Stack/Relay:   capc -s 1 -r 7 -d

The curl commands this replaces:
  1. curl -X POST http://localhost:5000/api/switch/CH1A -d '{"state": 1}'
  2. curl -X POST http://localhost:5000/api/relay/1/7 -d '{"state": 1}'
  3. curl -X POST http://192.168.1.2:5001/api/switch/CH1A -d '{"state": 1}'
  4. curl -X POST http://192.168.1.2:5001/api/relay/1/7 -d '{"state": 1}'
"""

import argparse
import requests
import sys
import json
from typing import Optional

# Configuration
MAIN_SERVER_HOST = "localhost"
MAIN_SERVER_PORT = 5000
PI_SERVER_PORT = 5001

# Default Pi IPs (will be fetched from main server if needed)
PI_IPS = {
    "pi_1": "192.168.1.2",
    "pi_2": "192.168.1.3"
}


def get_main_server_url() -> str:
    """Get the main server base URL."""
    return f"http://{MAIN_SERVER_HOST}:{MAIN_SERVER_PORT}"


def get_pi_server_url(pi_ip: str) -> str:
    """Get a Pi server base URL."""
    return f"http://{pi_ip}:{PI_SERVER_PORT}"


def fetch_pi_ips() -> dict:
    """Fetch Pi IP addresses from main server."""
    try:
        response = requests.get(f"{get_main_server_url()}/api/status", timeout=2)
        if response.ok:
            data = response.json()
            pis = {}
            for pi_id, pi_data in data.get("raspberry_pis", {}).items():
                if "ip_address" in pi_data:
                    pis[pi_id] = pi_data["ip_address"]
            return pis if pis else PI_IPS
    except Exception as e:
        print(f"âš ï¸  Warning: Could not fetch Pi IPs from main server: {e}", file=sys.stderr)
    return PI_IPS


def determine_pi_for_switch(switch_name: str) -> Optional[str]:
    """
    Determine which Pi controls a given switch.
    Returns Pi IP address.
    """
    try:
        response = requests.get(f"{get_main_server_url()}/api/status", timeout=2)
        if response.ok:
            data = response.json()
            # Extract chassis number from switch name (e.g., CH1A -> 1, CH2 -> 2)
            chassis_match = switch_name.upper().replace("CH", "").lstrip("0123456789")
            chassis_num = int(switch_name.upper().replace("CH", "")[0])
            
            for pi_id, pi_data in data.get("raspberry_pis", {}).items():
                if chassis_num in pi_data.get("chassis", []):
                    return pi_data.get("ip_address")
    except Exception as e:
        print(f"âš ï¸  Warning: Could not determine Pi for switch: {e}", file=sys.stderr)
    
    # Fallback: assume first Pi
    pis = fetch_pi_ips()
    return list(pis.values())[0] if pis else "192.168.1.2"


def control_by_switch_name(switch_name: str, state: int, direct: bool = False, pi_ip: Optional[str] = None) -> bool:
    """
    Control Mode 1 or 3: By switch name via main server or Pi direct.
    
    Args:
        switch_name: Switch name like "CH1A", "CH2", etc.
        state: 0 (OFF) or 1 (ON)
        direct: If True, contact Pi directly (Mode 3), else main server (Mode 1)
        pi_ip: Optional Pi IP for direct mode. If None, will auto-detect.
    
    Returns:
        True if successful, False otherwise
    """
    switch_name = switch_name.upper()
    
    if direct:
        # Mode 3: Contact Pi directly
        if not pi_ip:
            pi_ip = determine_pi_for_switch(switch_name)
        
        url = f"{get_pi_server_url(pi_ip)}/api/switch/{switch_name}"
        server_name = f"Pi @ {pi_ip}"
    else:
        # Mode 1: Contact main server
        url = f"{get_main_server_url()}/api/switch/{switch_name}"
        server_name = "Main Server"
    
    try:
        response = requests.post(
            url,
            json={"state": state},
            headers={"Content-Type": "application/json"},
            timeout=5
        )
        
        if response.ok:
            result = response.json()
            state_text = "ON" if state == 1 else "OFF"
            print(f"âœ“ Switch {switch_name} turned {state_text} via {server_name}")
            return True
        else:
            error = response.json().get("error", "Unknown error")
            print(f"âœ— Error: {error}", file=sys.stderr)
            return False
            
    except requests.exceptions.ConnectionError:
        print(f"âœ— Error: Could not connect to {server_name} at {url}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"âœ— Error: {e}", file=sys.stderr)
        return False


def control_by_hat_relay(hat_num: int, relay_num: int, state: int, direct: bool = False, pi_ip: Optional[str] = None) -> bool:
    """
    Control Mode 2 or 4: By HAT number and relay number.
    
    Args:
        hat_num: HAT number (1-based, e.g., 1, 2, 3)
        relay_num: Relay number (1-based, e.g., 1-8)
        state: 0 (OFF) or 1 (ON)
        direct: If True, contact Pi directly (Mode 4), else main server (Mode 2)
        pi_ip: Optional Pi IP for direct mode
    
    Returns:
        True if successful, False otherwise
    """
    if direct:
        # Mode 4: Contact Pi directly
        if not pi_ip:
            # For direct mode, we need to know which Pi has this HAT
            # For now, use the first Pi as default, but ideally should be specified
            pis = fetch_pi_ips()
            pi_ip = list(pis.values())[0] if pis else "192.168.1.2"
            print(f"â„¹ï¸  Auto-selected Pi @ {pi_ip} for HAT {hat_num}", file=sys.stderr)
        
        url = f"{get_pi_server_url(pi_ip)}/api/relay/{hat_num}/{relay_num}"
        server_name = f"Pi @ {pi_ip}"
    else:
        # Mode 2: Contact main server
        url = f"{get_main_server_url()}/api/relay/{hat_num}/{relay_num}"
        server_name = "Main Server"
    
    try:
        response = requests.post(
            url,
            json={"state": state},
            headers={"Content-Type": "application/json"},
            timeout=5
        )
        
        if response.ok:
            result = response.json()
            state_text = "ON" if state == 1 else "OFF"
            print(f"âœ“ HAT {hat_num} Relay {relay_num} turned {state_text} via {server_name}")
            return True
        else:
            error = response.json().get("error", "Unknown error")
            print(f"âœ— Error: {error}", file=sys.stderr)
            return False
            
    except requests.exceptions.ConnectionError:
        print(f"âœ— Error: Could not connect to {server_name} at {url}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"âœ— Error: {e}", file=sys.stderr)
        return False


def get_switch_status(switch_name: str, direct: bool = False, pi_ip: Optional[str] = None) -> None:
    """Get the status of a specific switch."""
    switch_name = switch_name.upper()
    
    if direct:
        if not pi_ip:
            pi_ip = determine_pi_for_switch(switch_name)
        url = f"{get_pi_server_url(pi_ip)}/api/switch/{switch_name}"
        server_name = f"Pi @ {pi_ip}"
    else:
        url = f"{get_main_server_url()}/api/switch/{switch_name}"
        server_name = "Main Server"
    
    try:
        response = requests.get(url, timeout=5)
        if response.ok:
            data = response.json()
            state_text = "ON" if data.get("state") == 1 else "OFF"
            print(f"Switch {switch_name}: {state_text}")
            print(f"  Source: {server_name}")
            if "pi" in data:
                print(f"  Controlled by: {data['pi']}")
            if "hat" in data and "relay" in data:
                print(f"  Hardware: HAT {data['hat']}, Relay {data['relay']}")
        else:
            error = response.json().get("error", "Unknown error")
            print(f"âœ— Error: {error}", file=sys.stderr)
    except Exception as e:
        print(f"âœ— Error: {e}", file=sys.stderr)


def list_all_switches(direct: bool = False, pi_ip: Optional[str] = None) -> None:
    """List all available switches."""
    if direct:
        if not pi_ip:
            pis = fetch_pi_ips()
            pi_ip = list(pis.values())[0] if pis else "192.168.1.2"
        url = f"{get_pi_server_url(pi_ip)}/api/switch/list"
        server_name = f"Pi @ {pi_ip}"
    else:
        url = f"{get_main_server_url()}/api/switch/list"
        server_name = "Main Server"
    
    try:
        response = requests.get(url, timeout=5)
        if response.ok:
            data = response.json()
            switches = data.get("switches", {})
            
            print(f"ðŸ“¡ Available Switches (from {server_name}):\n")
            
            # Group by chassis
            chassis_groups = {}
            for name, state in switches.items():
                chassis_match = name.upper().replace("CH", "")
                chassis_num = int(chassis_match[0])
                if chassis_num not in chassis_groups:
                    chassis_groups[chassis_num] = []
                chassis_groups[chassis_num].append((name, state))
            
            for chassis_num in sorted(chassis_groups.keys()):
                print(f"  Chassis {chassis_num}:")
                for name, state in sorted(chassis_groups[chassis_num]):
                    state_text = "ON" if state == 1 else "OFF"
                    print(f"    {name}: {state_text}")
                print()
        else:
            error = response.json().get("error", "Unknown error")
            print(f"âœ— Error: {error}", file=sys.stderr)
    except Exception as e:
        print(f"âœ— Error: {e}", file=sys.stderr)


def main():
    parser = argparse.ArgumentParser(
        description="CAPC - CASM Analog Power Controller CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Control by switch name (via main server)
  capc -n CH1A --on          # Turn CH1A ON
  capc -n CH2 --off          # Turn CH2 OFF
  capc -n CH1A               # Get status of CH1A
  
  # Control by stack/relay number (via main server)
  capc -s 1 -r 7 --on        # Turn Stack 1, Relay 7 ON
  capc -s 2 -r 3 --off       # Turn Stack 2, Relay 3 OFF
  
  # Direct Pi control (add -d flag)
  capc -n CH1A --on -d       # Turn CH1A ON via Pi directly
  capc -s 1 -r 7 --on -d     # Turn Stack 1 Relay 7 ON via Pi directly
  capc -n CH1A -d -p 192.168.1.2  # Specify Pi IP
  
  # List all switches
  capc --list                # List from main server
  capc --list -d             # List from Pi
  
  # Get system status
  capc --status              # Show Pi status from main server

The curl equivalents:
  capc -n CH1A --on
    â†’ curl -X POST http://localhost:5000/api/switch/CH1A -d '{"state": 1}'
  
  capc -s 1 -r 7 --on
    â†’ curl -X POST http://localhost:5000/api/relay/1/7 -d '{"state": 1}'
  
  capc -n CH1A --on -d
    â†’ curl -X POST http://192.168.1.2:5001/api/switch/CH1A -d '{"state": 1}'
  
  capc -s 1 -r 7 --on -d -p 192.168.1.2
    â†’ curl -X POST http://192.168.1.2:5001/api/relay/1/7 -d '{"state": 1}'
"""
    )
    
    # Control modes
    parser.add_argument("-n", "--name", help="Switch name (e.g., CH1A, CH2)")
    parser.add_argument("-s", "--stack", type=int, help="Stack/HAT number (1-based)")
    parser.add_argument("-r", "--relay", type=int, help="Relay number (1-based, 1-8)")
    
    # State control
    state_group = parser.add_mutually_exclusive_group()
    state_group.add_argument("--on", action="store_true", help="Turn switch ON")
    state_group.add_argument("--off", action="store_true", help="Turn switch OFF")
    
    # Server selection
    parser.add_argument("-d", "--direct", action="store_true", 
                       help="Contact Pi server directly (instead of main server)")
    parser.add_argument("-p", "--pi", help="Pi IP address (for direct mode)")
    
    # Information commands
    parser.add_argument("--list", action="store_true", help="List all switches")
    parser.add_argument("--status", action="store_true", help="Show system status")
    
    args = parser.parse_args()
    
    # Handle status command
    if args.status:
        try:
            response = requests.get(f"{get_main_server_url()}/api/status", timeout=5)
            if response.ok:
                data = response.json()
                print("ðŸ“Š System Status:\n")
                print(f"Total Switches: {data.get('total_switches', 0)}")
                print(f"Raspberry Pis: {len(data.get('raspberry_pis', {}))}\n")
                
                for pi_id, pi_data in data.get("raspberry_pis", {}).items():
                    status_icon = "ðŸŸ¢" if pi_data.get("status") == "online" else "ðŸ”´"
                    print(f"  {status_icon} {pi_id}:")
                    print(f"     IP: {pi_data.get('ip_address')}")
                    print(f"     Status: {pi_data.get('status')}")
                    print(f"     Chassis: {pi_data.get('chassis', [])}")
                    print()
            else:
                print("âœ— Could not fetch status", file=sys.stderr)
                sys.exit(1)
        except Exception as e:
            print(f"âœ— Error: {e}", file=sys.stderr)
            sys.exit(1)
        return
    
    # Handle list command
    if args.list:
        list_all_switches(direct=args.direct, pi_ip=args.pi)
        return
    
    # Validate control arguments
    if args.name and (args.stack or args.relay):
        print("âœ— Error: Cannot specify both --name and --stack/--relay", file=sys.stderr)
        sys.exit(1)
    
    if (args.stack and not args.relay) or (args.relay and not args.stack):
        print("âœ— Error: Must specify both --stack and --relay together", file=sys.stderr)
        sys.exit(1)
    
    if not args.name and not args.stack and not args.list and not args.status:
        parser.print_help()
        sys.exit(1)
    
    # Control by switch name
    if args.name:
        if args.on:
            success = control_by_switch_name(args.name, 1, direct=args.direct, pi_ip=args.pi)
            sys.exit(0 if success else 1)
        elif args.off:
            success = control_by_switch_name(args.name, 0, direct=args.direct, pi_ip=args.pi)
            sys.exit(0 if success else 1)
        else:
            # Just get status
            get_switch_status(args.name, direct=args.direct, pi_ip=args.pi)
            return
    
    # Control by stack/relay number
    if args.stack and args.relay:
        if args.on:
            success = control_by_hat_relay(args.stack, args.relay, 1, direct=args.direct, pi_ip=args.pi)
            sys.exit(0 if success else 1)
        elif args.off:
            success = control_by_hat_relay(args.stack, args.relay, 0, direct=args.direct, pi_ip=args.pi)
            sys.exit(0 if success else 1)
        else:
            print("âœ— Error: Must specify --on or --off for stack/relay control", file=sys.stderr)
            sys.exit(1)


if __name__ == "__main__":
    main()

